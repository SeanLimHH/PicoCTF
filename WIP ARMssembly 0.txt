https://play.picoctf.org/practice/challenge/160?page=2

Description:

What integer does this program print with arguments 266134863 and 1592237099?
File: chall.S Flag format: picoCTF{XXXXXXXX} ->
(hex, lowercase, no 0x, and 32 bits. ex. 5614267 would be picoCTF{0055aabb})

chall.S:

	.arch armv8-a
	.file	"chall.c"
	.text
	.align	2
	.global	func1
	.type	func1, %function
func1:
	sub	sp, sp, #16
	str	w0, [sp, 12]
	str	w1, [sp, 8]
	ldr	w1, [sp, 12]
	ldr	w0, [sp, 8]
	cmp	w1, w0
	bls	.L2
	ldr	w0, [sp, 12]
	b	.L3
.L2:
	ldr	w0, [sp, 8]
.L3:
	add	sp, sp, 16
	ret
	.size	func1, .-func1
	.section	.rodata
	.align	3
.LC0:
	.string	"Result: %ld\n"
	.text
	.align	2
	.global	main
	.type	main, %function
main:
	stp	x29, x30, [sp, -48]!
	add	x29, sp, 0
	str	x19, [sp, 16]
	str	w0, [x29, 44]
	str	x1, [x29, 32]
	ldr	x0, [x29, 32]
	add	x0, x0, 8
	ldr	x0, [x0]
	bl	atoi
	mov	w19, w0
	ldr	x0, [x29, 32]
	add	x0, x0, 16
	ldr	x0, [x0]
	bl	atoi
	mov	w1, w0
	mov	w0, w19
	bl	func1
	mov	w1, w0
	adrp	x0, .LC0
	add	x0, x0, :lo12:.LC0
	bl	printf
	mov	w0, 0
	ldr	x19, [sp, 16]
	ldp	x29, x30, [sp], 48
	ret
	.size	main, .-main
	.ident	"GCC: (Ubuntu/Linaro 7.5.0-3ubuntu1~18.04) 7.5.0"
	.section	.note.GNU-stack,"",@progbits

Solution:

I spent a significant amount on time in learning the basics as i only know a little bit about
ARM assembly. Here are the notes i took which may or may not be correct:

The dot is the directive, but what does it mean?:
https://downloads.ti.com/docs/esd/SPNU118O/Content/SPNU118O_HTML/assembler_directives.html#:~:text=Assembler%20directives%20supply%20data%20to,Control%20the%20appearance%20of%20listings

A directive is best understood as an organiser for data and instructions on how to manage the data.
For example,

.data directive allows for data to be thrown into the "data" holder with its own rules.
Different directive names have their own rules; hence why it is called a directive.

A .data directive will thus have different set of instructions from a .type directive, or any other type of directive.

This rules can be simple or complicated, but the documentation shows how data is being
managed in .data and how it is being used.

The website above explains a few common directives:

    These directives associate portions of an assembly language program with the appropriate sections:

    The .bss directive reserves space in the .bss section for uninitialized variables.
    The .data directive identifies portions of code in the .data section.
		The .data section usually contains initialized data.
    The .retain directive can be used to indicate that the current or specified section must be included in the linked output.
		Thus even if no other sections included in the link reference the current or specified section, it is still included in the link.
    The .retainrefs directive can be used to force sections that refer to the specified section.
		This is useful in the case of interrupt vectors.
    The .sect directive defines an initialized named section and associates subsequent code or data with that section.
		A section defined with .sect can contain code or data.
    The .text directive identifies portions of code in the .text section.
		The .text section usually contains executable code.
    The .usect directive reserves space in an uninitialized named section.
		The .usect directive is similar to the .bss directive, but it allows you to reserve space separately from the .bss section.

The main takeaway here is that in each of this directive, there is a set of assembly instructions to handle the data.
And these differ from one another.

Returning back to this challenge, we can focus on what is being used:

The first line with .arch armv8-a suggests that the architecture being used is armv8-a:
https://developer.arm.com/-/media/Arm%20Developer%20Community/PDF/Learn%20the%20Architecture/Armv8-A%20Instruction%20Set%20Architecture.pdf?revision=ebf53406-04fd-4c67-a485-1b329febfb3e

So whatever we check should be in line with the above document.


.align meaning
https://stackoverflow.com/questions/27528796/what-does-align-in-arm-architecture
So the .align 2 in the code means its rightmost 1 bit is 0.
    This can also be expressed as "an address is 2^m-bytes aligned if its rightmost m bits are all zero"

We first look at main; it is where the program's entry point is at.

https://azeria-labs.com/arm-data-types-and-registers-part-2/
This link explains the registers;
SP: R13, stack pointer.

We can check what the operations mean:
https://azeria-labs.com/arm-instruction-set-part-3/
MNEMONIC{S}{condition} {Rd}, Operand1, Operand2

MNEMONIC     - Short name (mnemonic) of the instruction
{S}          - An optional suffix. If S is specified, the condition flags are 
				updated on the result of the operation
{condition}  - Condition that is needed to be met in order for the instruction to 
				be executed
{Rd}         - Register (destination) for storing the result of the instruction
Operand1     - First operand. Either a register or an immediate value 
Operand2     - Second (flexible) operand. Can be an immediate value (number) 
or a register with an optional shift

The relevant parts are {Rd}, Operand1 and Operand2.

So in the challenge: in func1 first line:

	sub	sp, sp, #16

We are subtracting actual value 16 (immediate value) from SP, then storing it in SP.
Essentially replacing the SP with itself - 16

https://azeria-labs.com/functions-and-the-stack-part-7/
From this, we can see that the purpose of doing so is allocation of memory.
We use Stack for storing temporary data such as local variables of some function,
environment variables which helps us to transition between the functions, etc.
We interact with the stack using PUSH and POP instructions.

The SP registers holds the conceptual "pointer" to the next available address in the stack.


The second line is trickier; it has square brackets:

	str	w0, [sp, 12]

In the same website we can find notes on this:
https://azeria-labs.com/memory-instructions-load-and-store-part-4/

ARM uses a load-store model for memory access which means that only
load/store (LDR and STR) instructions can access memory. While on x86 most
instructions are allowed to directly operate on data in memory, on ARM
data must be moved from memory into registers before being operated on.
LDR Ra, [Rb] means value in the register Rb is loaded onto Ra.

	str	w0, [sp, 12]

Is the offset form: 12 is another variation of an intermediate value? The answer in:
https://stackoverflow.com/questions/59020911/what-do-and-mean-in-arm-assembly-language

So it is like #12.

Here we have in main:

	stp	x29, x30, [sp, -48]!

This article succinctly describes the first part with

https://stackoverflow.com/questions/64638627/explain-arm64-instruction-stp

This is store pair of registers (STP); it stores 2 32 word or 64-bit doublewords
into registers x29 and x30.

The line is pushing onto the stack value in register 30 to value in register 29:
https://developer.arm.com/documentation/ddi0602/2023-12/Base-Instructions/STP--Store-Pair-of-Registers-

Registers 29: 

[sp, -48] is the offset -48 from the value in the stack pointer.

Here when we see the last line: 
	ldp	x29, x30, [sp], 48

We can deduce the stp line is allocating memory on the stack, function prologue, and this ldp line
is popping off the stack; reversing this allocation, function epilogue:
https://stackoverflow.com/questions/14765406/function-prologue-and-epilogue-in-c
https://www.learnvulnerabilityresearch.com/stack-frame-function-prologue
https://azeria-labs.com/functions-and-the-stack-part-7/

Every function has a prologue.
This prologue will look same as in other functions in the same program.
The general steps:
	The first is always pushing the Frame and Link Register (FP and LR) onto the stack
		So this should be 
			stp	x29, x30, [sp, -48]!
			
			x29 is the FP and x30 is the LR?

	So at this point, the FP and LR has the same value as the SP

What is LR: https://www.sciencedirect.com/topics/engineering/link-register#:~:text=The%20special%20link%20register%20(LR,to%20a%20generic%20handler%20routine.
LR is Link Register used to hold the return address for a function call.

What is BP: https://www.baskent.edu.tr/~tkaracay/etudio/ders/prg/pascal/PasHTM2/pas/lowlevel.html#:~:text=BP%20is%20base%20pointer%2C%20SP,to%20point%20the%20current%20stack.
BP is the Base Pointer used to preserve space to use local variables. This is also known as EBP.

The video describes what happens during function calls: https://www.youtube.com/watch?v=RU5vUIl1vRs
There is an instruction pointer that points to the next line of code to be executed.
This is the EIP.

The ESP is the SP pointer. Points to an existing value at the top of the stack.

When the program faces a function call, the ESP is decremented to the next available
empty index in the stack. Then, the EIP's value is pushed onto the stack.

Then, when the running line is RET; the EIP becomes blank, the EIP is going to incremented to the value of the stack'
s last value in the stack popped.

The ESP will however assume the next value in the stack since it has been popped.

Then moving onto the next line after the function call has been completed.

At this point, the state of ESP and EIP will be like as before the function call.

The general sequence of function prologue on ARM: https://devblogs.microsoft.com/oldnewthing/20210622-00/?p=105332

    push    {r4-r7,r11,lr}      ; save a bunch of registers
    add     r11, sp, #0x10      ; link into frame pointer chain
    sub     sp, sp, #0x20       ; allocate space for locals
                                ; and outbound stack parameters

Going back to the challenge, we can see a similar structure:

	stp	x29, x30, [sp, -48]!
	add	x29, sp, 0
	str	x19, [sp, 16]

Where str x19 line stores value of Register 19 into an address equal to SP with offset of 16.
This is the final line of the prologue.

Then one can trace the epilogue's start:

	ldr	x19, [sp, 16]

Where the Register 19 is loaded with the value in address equal to SP with offset of 16

Going back to the code snippet:

	str	w0, [x29, 44]
	str	x1, [x29, 32]

The 'w' in w0 represent the lower 32 bits of the registers being used: 9.1.2, https://diveintosystems.org/book/C9-ARM64/basics.html
32 bits of data is thus being stored here, hence register w is used.
This also renders the upper 32 bits of the registers inaccessible

This line stores the lower 32 bits of register 0 with value in address equal to register 29 with offset of 44.

The next line stores similarly, but now just register 1 value in [x29 + 32].

The next line:

	ldr	x0, [x29, 32]

This loads register x0 with value in address register 29 with offset 32

	add	x0, x0, 8
	ldr	x0, [x0]

The first line adds into x0 itself 8 bytes.

Googling search the significance of these registers,
https://stackoverflow.com/questions/261419/what-registers-to-save-in-the-arm-c-calling-convention

The link suggests the following:

r0-r3 are the argument and scratch registers; r0-r1 are also the result registers
r4-r8 are callee-save registers
r9 might be a callee-save register or not (on some variants of AAPCS it is a special register)
r10-r11 are callee-save registers
r12-r15 are special registers

This x0 can be the argument register then.
8 bytes will increment to the next register. 1 byte = 8 bits, 8*8 = 64 bits.

So the LDR line

	ldr	x0, [x29, 32]

Loads the register with the memory location.

The next line

	ldr x0, [x0]
	
Will then override the value within register 0 with this value in the memory location.

Since this is register 0, it could be taken that [x29, 32] has the value of the input of the user.

Then we see BL: https://stackoverflow.com/questions/34091898/bl-instruction-arm-how-does-it-work
This means that the execution of the code will jump to a function call atoi, then return back
atoi converts string ASCII argument into integer.

So bl atoi is like calling an inbuilt function; its return value will be loaded into LR (x30).

The value loaded into this function is in x0.

So it converts the value in x0 to integer. Recall from the above, this means lower 32 bits are used.
Then, that is probably why the author did the next lines:

	mov	w19, w0

Note the 'w' prefix here; this means this operation is dealing with the lower 32 bits of the register 0.
This line moves into the lower 32 bits of register 19.
This will thus assume the integer value of argument 1.

	mov	w0, w19
	bl	func1
	mov	w1, w0

w19 will equal w0.

Then it invokes label func1:

